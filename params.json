{"name":"Decisions","tagline":"A Claims based model for resolving bespoke authorization/security operations.","body":"Decisions\r\n==========\r\n\r\nA Claims based model for resolving bespoke authorization/security operations. Provides a layer of abstraction between authorization details and calling the operation. Thus, allowing the same operation to resolve differently depending on setup of Decisions not a change to your codebase. Useful when you have a lot of private or security driven parts to your application and want to have flexibility to change your security model with minimal risk and time involved.\r\n\r\nOverview\r\n-------------------------\r\n\r\nSelf contained WebAPI application that uses RESTful endpoints to describe claims that can then be configured to execute bespoke code for decision resolution. \r\n\r\nDecisions has three key elements. A Policy, a Environment and a Decision. Each Decision is an Expression involving one or more Policies that resolves to a boolean True or False. Each Policy represents an element of the Decision and can use one or more Environments to resolve itself to a boolean True or False.\r\n\r\nDecisions\r\n-------------------------\r\n\r\nA Decision is a simple string that is described as part of the Decisions.config or like file you initialize Decisions with. Example of Decisions are:\r\n\r\n* True\r\n* False\r\n* True OR False\r\n* True AND False\r\n* True AND (True OR False)\r\n* !False\r\n\r\nYou can use Policies as part of Decisions, there are also some short hand conventions. The following can also be used:\r\n\r\n* . instead of AND\r\n* + instead of OR\r\n\r\nEnvironments\r\n-------------------------\r\n\r\nA Environment is some object that can be retrieved by the information available in the DecisionContext. The object can then be used within a Policy to help resolve it. You will need to implement IEnvironmentProvider in order to provide Environments in your Policies. The following is a simple example that uses the SourceId as a Current Username to resolve further details about that User.\r\n\r\n\r\n```c#\r\npublic class EnvironmentProvider : DefaultEnvironmentProvider \r\n{\r\n    public override Task<dynamic> GetAsync(string alias, DecisionContext context)\r\n    {\r\n        if (alias == EnvironmentKeys.CURRENT_USER)\r\n        {\r\n            return Task.FromResult((object)userService.GetUser(context.SourceId));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nPolicies\r\n-------------------------\r\n\r\nA Policy is a atomically resolvable operation which alone or with other Policies resolves a Decision. Implementing one allows you to provide custom logic while executing a Decision. The Policy can then be registered with a PolicyProvider like the Example implementation to be executed in a Decision. Recommended approach for implementing a Policy is outlined below.\r\n\r\n```c#\r\npublic class IsCurrentUserPolicy : AbstractPolicy\r\n{\r\n    public override bool Decide(DecisionContext context)\r\n    {\r\n        var currentUser = GetEnvironment(EnvironmentKeys.CURRENT_USER, context) as User;\r\n        return context.Target.Id == currentUser.Id;\r\n    }\r\n}\r\n```\r\n\r\nInstallation\r\n-------------------------\r\n\r\nInstall the Decisions NuGet package into your API WebSite, or whichever Website you would like to host Decisions from. Install the Decisions.Contracts and Decisions.Utility NuGet packages into your Domain/Application layers and apply as set out in the Usage section below.\r\n\r\nOnce the NuGet packages are installed, you will need to implement policies and setup a Decisions.Config file then weave the implementations together with your chosen Inversion of Control strategy. You should implement a Decisions.Contracts.IResolver and apply it to Injector.Resolver on application startup.\r\n\r\nUsage\r\n-------------------------\r\n\r\n### Basic\r\n\r\n```c#\r\nvar decisionsService = Injector.Get<IDecisionsService>();\r\nvar context = new DecisionContext { Namespace = \"Example\", SourceId = \"User\", Role = \"Role\", Target = new { @id = 1 }};\r\nvar decision = await decisionsService.CheckAsync(context);\r\nif(!decision) throw new UnauthorizedAccessException();\r\n```\r\n\r\n### Fluent\r\n\r\n```c#\r\nvar decisionsService = Injector.Get<IDecisionsService>();\r\nvar context = DecisionContext.Create().Using(\"Example\").As(\"User\").Has(\"Role\").On(new { @id = 1 });\r\nvar decision = await decisionsService.CheckAsync(context);\r\nif(!decision) throw new UnauthorizedAccessException();\r\n```\r\n\r\n### Simplied Fluent\r\n\r\n```c#\r\nvar decision = await DecisionContext.Create().Using(\"Example\").As(\"User\").Has(\"Role\").On(new { @id = 1 }).Check();\r\nif(!decision) throw new UnauthorizedAccessException();\r\n```\r\n\r\n### Lamda Simplified Fluent\r\n\r\n```c#\r\nvar decision = await DecisionContext.Check(a => a.Using(\"Example\").As(\"User\").Has(\"Role\").On(new { @id = 1 }));\r\nif(!decision) throw new UnauthorizedAccessException();\r\n```\r\n\r\n### Lamda Simplified Fluent with Defaults\r\n\r\n```c#\r\nvar decision = await DecisionContext.Check(a => a.Using(\"Example\").Has(\"Role\").On(new { @id = 1 }));\r\nif(!decision) throw new UnauthorizedAccessException();\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}